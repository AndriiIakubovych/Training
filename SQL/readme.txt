Создать БД с тремя таблицами: Salespeople (продавцы), Customers (покупатели), Orders (заказы). Создать необходимые связи между таблицами.
Salespeople: snum - уникальный номер, присваеваемый каждому продавцу, номер служащего (это первичный ключ таблицы), sname - фамилия продавца, city - место, где находится продавец, т. е. один из офисов компании.
Customers: cnum - уникальный номер, присваеваемый каждому покупателю, номер служащего (это первичный ключ таблицы), cname - фамилия покупателя, city - место, где находится покупатель (в действительности, это один из офисов компании, а не место проживания покупателя), rating - числовой код, который показывает уровень предпочтения, присвоенный данному покупателю (большие номера соответствуют большим предпочтениям; NULL обозначает покупателя, которому ещё не присвоен рейтинг), snum - номер продавца, прикреплённого к данному покупателю (это внешний ключ, ссылающийся на snum из Salespeople; на случай недоступности продавца имеется механизм, позволяющий другим продавцам работать с покупателем, когда это необходимо).
Orders: onum - уникальный номер, присваиваемый каждой покупке, amt - сумма покупки, odate - дата покупки, cnum - номер покупателя, делающего покупку (это внешний ключ, ссылающийся на cnum из Customers), snum - номер продавца, совершившего продажу (это внешний ключ, ссылающийся на snum из Salespeople; обычно это продавец, прикреплённый к покупателю в таблице Customers, но не всегда).

1.1. Написать оператор CREATE TABLE, который создаёт таблицу Customers.
1.2. Написать оператор ALTER TABLE, который удаляет столбец rating из таблицы Customers. Считать, что таблица пуста.
1.3. Написать оператор, который удаляет таблицу Customers и ссылающуюся на неё таблицу Orders.

2.1. Создать таблицу Orders так, чтобы все значения onum, а также комбинации cnum и snum отличались друг от друга, а в столбце date не было NULL-значений.
2.2. Создать таблицу Salespeople так, чтобы по умолчанию комиссионные составляли 10% при отсутствии NULL-значений, а snum был первичным ключом.
2.3. Создать таблицу Orders так, чтобы значение onum было больше, чем cnum, а cnum больше snum. Запретить значение NULL в любом из этих столбцов.

3.1. Создать таблицу CityOrders. Она должна содержать столбцы onum, amt и snum из таблицы Orders, а также столбцы cnum и city из таблицы Customers, чтобы вместе с заказом каждого покупателя можно было ввести город, в котором он проживает. Для CityOrders первичным ключом будет onum. Ограничить все столбцы CityOrders так, чтобы они соответствовали столбцам Customers и Orders. Считать, что родительские ключи в этих таблицах уже имеют необходимые ограничения.
3.2. Переопределить таблицу Orders следующим образом: добавить новый столбец с названием prev, который для каждого заказа содержит onum предыдущего заказа данного покупателя. Реализовать это с помощью внешнего ключа, ссылающегося на саму таблицу Orders. Внешний ключ должен ссылаться также на cnum покупателя, обеспечивая однозначную связь между текущим заказом и тем заказом, на который он указывает.
3.3. Предположим, что каждый заказ может содержать любое количество пунктов, которые учитываются отдельно с целью инвентаризации. Тем самым отношение пунктов к заказам является примером классического отношения "многие к одному", требующим использования другой таблицы. Создать таблицу Items, содержащую для каждого пункта его номер, название, цену и номер соответствующего заказа, по которому можно получить всю информацию о заказе.
3.4. Переопределить таблицу Customers таким образом, чтобы удаление продавца приводило к установке в NULL значения snum для всех его покупателей, а изменение номера продавца автоматически отображалось бы в таблице Customers так, чтобы все связи с его покупателями сохранялись.

4.1. Составить команду, которая помещает в таблицу Salespeople следующие значения в указанном порядке: city = San Jose, name = Blanco, comm = NULL, snum = 1100.
4.2. Написать команду, которая удаляет все заказы покупателя Clemens из таблицы Orders.
4.3. Написать команду, которая увеличивает рейтинг всех покупателей в Риме на 100.
4.4. Продавец Serres уволился. Прикрепить его покупателей к продавцу Motika.

5.1. Написать оператор SELECT, который выводит номер заказа, сумму и дату для всех строк в таблице Orders.
5.2. Составить запрос, который выводит все строки таблицы Customers с нормером продавца 1001.
5.3. Написать запрос, который выводит таблицу Salespeople в следующем порядке: city, sname, snum, comm.
5.4. Составить запрос, который выводит без повторов значения snum для всех продавцом, обслуживающих заказы из таблицы Orders.
5.5. Написать запрос, который выдаёт имена всех продавцов в Лондоне с комиссионными более 0.10.
5.6. Написать запрос к таблице Customers, из результата которого будут исключены все покупатели с рейтингом <= 100, если только они не находятся в Риме.
5.7. Каким будет результат следующего запроса?
     SELECT * FROM Orders WHERE (amt < 1000 OR NOT (odate = '10.03.2000' AND cnum > 2003));
5.8. Что будет результатом следующего запроса?
     SELECT * FROM Orders WHERE NOT ((odate = '10.03.2000' OR snum > 1006) AND amt >= 1500);
5.9. Каким образом можно упростить следующий запрос (считать, что столбец comm не содержит NULL-значений)?
     SELECT snum, sname, city, comm FROM Salespeople WHERE (comm >= 0.12 OR comm <= 0.14);

6.1. Составить два запроса, которые выводят все заказы, полученные 3 или 4 октября 2000 г.
6.2. Написать запрос, который выводит всех покупателей, чьи имена начинаются на буквы с A по G.
6.3. Написать запрос, который выбирает всех покупателей, чьи имена начинаются на букву C (как заглавную, так и строчную).
6.4. Составить запрос, который выбирает все заказы, которые не содержат нулей или NULL-значений в столбце amt (amount).
6.5. Написать запрос, который подсчитывает число заказов, сделанных 3 октября.
6.6. Написать запрос, который подсчитывает количество различных непустых значений столбца city в таблице Customers.
6.7. Составить запрос, который выбирает наименьший заказ каждого покупателя.
6.8. Написать запрос, который выбирает первого покупателя (в алфавитном порядке), чьё имя начинается на букву G.
6.9. Написать запрос, который выбирает наибольший рейтинг в каждом городе.
6.10. Составить запрос, который подсчитывает, сколько продавцов ежедневно получает заказы. Продавец, получающий в день более одного заказа должен учитываться только один раз.

7.1. Предположим, что каждый продавец имеет 12% комиссионных. Написать запрос к таблице Orders, который выводит номер заказа, номер продавца и размер комиссионных для данного заказа.
7.2. Написать запрос к таблице Customers, который ищет максимальный рейтинг в каждом городе. Вывести данные в формате:
     For the city (city), the highest rating is: (rating);
7.3. Составить запрос, который перечисляет покупателей в порядке убывания рейтинга. Выведите сначала столбец rating, а затем имя и номер покупателя.
7.4. Написать запрос, который подсчитывает общую сумму заказов за каждый день и располагает результаты в порядке убывания.
7.5. Составить запрос, который для всех покупателей из Парижа заменяет город на Брюссель, а для всех остальных покупателей в списке их настоящие города.
7.6. Написать оператор UPDATE, который увеличивает рейтинг всех покупателей на 100. Предполагается, что покупатели могут иметь рейтинг NULL, в этом случае он должен стать равным 100.

8.1. Написать запрос, который выводит номер каждого заказа вместе с именем покупателя, сделавшего этот заказ.
8.2. Составить запрос, который показывает всех покупателей, обслуживаемых продавцом с комиссионными более 12%. Вывести имя покупателя, имя продавца и комиссионные продавца.
8.3. Написать запрос, который рассчитывает комиссионные продавца от каждого заказа покупателей, имеющих рейтинг выше 100.
8.4. Написать запрос, который выводит все пары продавцов, живущих в одном городе. Исключить комбинации продавца с самим собой, а также строки, в которых значения повторяются в обратном порядке.
8.5. Составить запрос, который выводит имена и города всех покупателей, имеющих тот же рейтинг, что и покупатель Hoffman. Использовать в запросе номер покупателя Hoffman, а не его рейтинг, чтобы запрос можно было применять и при изменении рейтинга.
8.6. Изменить следующий запрос так, чтобы служащие, не имеющие менеджеров были включены в результат:
     SELECT under.empno, under.name, over.name FROM Employees under, Employees over WHERE under.manager = over.empno;
8.7. С какой целью в запрос включён последний предикат (a.cnum < b.cnum)?
     SELECT sname, Salespeople.snum, a.cname, b.cname FROM Customers a, Customers b, Salespeople WHERE a.snum = b.snum AND Salespeople.snum = a.snum AND a.cnum < b.cnum;

9.1. Написать запрос, в котором для получения всех заказов покупателя Cisneros используется подзапрос. Предполагается, что номер этого покупателя (cnum) неизвестен.
9.2. Составить запрос для вывода имён и рейтингов всех покупателей, сделавших заказы на сумму выше средней по всем заказам.
9.3. Написать запрос, который выводит общую стоимость заказов для тех продавцов, у которых эта сумма превышает стоимость самого крупного заказа в таблице.
9.4. Написать оператор SELECT с коррелированных подзапросом, который выбирает имена и номера всех покупателей с рейтингами, равными максимальному рейтингу для данного города.
9.5. Составить два запроса для вывода имён и номеров всех продавцов, в чьих городах есть покупатели, которых они не обслуживают. В одном запросе должно использоваться соединение, а в другом - коррелированный подзапрос. Какое решение более элегантно? Указание: один из способов данного решения заключается в том, чтобы найти всех покупателей, которые не обслуживаются данным продавцом, а затем проверить, находится ли кто-то из них в его городе.

10.1. Написать запрос, которые использует оператор EXISTS для извлечения всех продавцов, имеющих покупателей с рейтингом 300.
10.2. Решить предыдущую задачу с помощью соединения.
10.3. Написать запрос с оператором EXISTS для выбора всех продавцов, в чьих городах есть покупатели, которые к ним не прикреплены.
10.4. Составить запрос, который извлекает из таблицы Customers каждого покупателя, прикреплённого к продавцу, имеющему в данный момент как минимум ещё одного покупатея (помимо выбранного) с заказами в таблице Orders.
10.5. Написать запрос, который выбирает всех покупателей, чьи рейтинги больше или равны любому (в понимании SQL) из рейтингов покупателей продавца Serres.
10.6. Что будет результатом предыдущего запроса?
10.7. Написать запрос с использованием ANY или ALL, который находит всех продавцов, не имеющих покупателей в своих собственных городах.
10.8. Составить запрос, который выбирает все заказы со стоимостью, превышающей стоимость любого (в обычном смысле) заказа покупателей из Лондона.
10.9. Переписать предыдущий запрос, используя функцию MAX.

11.1. Создать объединение двух запросов, которое показывает имена, города и рейтинги всех покупателей. Сведения о тех из них, кто имеет рейтинг 200 и выше, должны сопровождаться словами "High rating", а об остальных словами "Low rating". NULL-рейтинги считаются низкими (low).
11.2. Напишите оператор, который выводит имена и номера всех продавцов и покупателей с более чем одним текущим заказом. Расположить результаты в алфавитном порядке.
11.3. Сформировать объединение трёх запросов. Первый должен выбирать snum всех продавцов в San Jose, второй - всех покупателей в San Jose, а третий onum всех заказов на 3 октября. Сохранить повторяющиеся значения в двух последних запросах, но исключить их дублирование с данными первого запроса.
11.4. Написать объединённый запрос, который находит всех продавцов из Лондона, имеющих в Лондоне как минимум одного покупателя. Вывести номера и имена продавцов.
11.5. Составить объединённый запрос, который находит всех продавцов с хотя бы одним заказом свыше $1000, сделанным покупателем из другого города. Вывести snum и cnum. Продавцы, имеющие такие заказы от нескольких покупателей, должны отображаться более одного раза.

12.1. Создать представление, показывающее всех покупателей с максимальным рейтингом.
12.2. Создать представление, показывающее количество продавцов в каждом городе.
12.3. Создать представление, показывающее среднюю и общую стоимости заказов для каждого продавца вместе с его именем. Считать, что все имена являются уникальными.
12.4. Создать представление, показывающее всех продавцов со многими покупателями.

13.1. Какие из этих представлений являются обновляемыми?
      1) CREATE VIEW DailyOrders AS SELECT DISTINCT cnum, snum, onum, odate FROM Orders;
      2) CREATE VIEW CusTotals AS SELECT cname, SUM(amt) FROM Orders, Customers WHERE Orders.cnum = Customers.cnum GROUP BY cname;
      3) CREATE VIEW ThirdOrders AS SELECT * FROM DailyOrders WHERE odate = '10.03.2000';
      4) CREATE VIEW Sales (name, number, percentage) AS SELECT sname, snum, comm * 100 FROM Salespeople WHERE city = 'San Jose';
13.2. Создать представление таблицы Salespeople с названием Commissions. Это представление должно включать только столбцы snum и comm. Обеспечить возможность ввода и изменения комиссионных в диапазоне от 0.10 до 0.20. Фактически в представлении будут видны только значения из этого диапазона.
13.3. Предположим, что работа производится с системой, поддерживающей LOCAL CHECK OPTION. Создать два представления, одно из которых ссылается на другое. Первое должно показывать все заказы на 3 октября. Второе, основанное на первом, должно исключать заказы со стоимостью менее $1000 долларов. Второе представление будет содержать CHECK OPTION, но его нужно использовать для размещения заказов на даты, отличные от 3 октября, и эти заказы должны приниматься.
13.4. Можно ли вывести с помощью представления из предыдущего задания заказ на 3 октября со стоимостью $900?

14.1. Предоставить Janet право изменять рейтинги покупателей.
14.2. Предоставить Stephen право на предоставление другим пользователям права выполнять запросы к таблице Orders.
14.3. Отозвать привелегию INSERT для таблицы Salespeople у Claire и у всех пользователей, которым она её предоставила.
14.4. Предоставить Jerry право применять к таблице Customers операторы INSERT и UPDATE. Вводимые значения рейтинга должны быть ограничены диапазоном от 100 до 500.
14.5. Разрешить Janet обращаться с запросом к таблице Customers, но ограничить доступ только теми покупателями, которые имеют наименьший рейтинг.